# Copyright 2025 SUSE LLC
---
name: Lib - Pipeline definition
on:
  workflow_call:
    inputs:
      run_linters:
        required: false
        type: boolean
        default: true

env:
  BRANCH_TRENTO_REPO: "main"
  TRENTO_REPO: "trento-project/mcp-server"
  IMG_DEV_TAG: "build-${{ github.sha }}"
  IMG_MODIFIER: "-ci"
  IMG_PLATFORMS: "linux/amd64" # TODO: add more? "linux/arm64".
  IMG_PREFIX: "ghcr.io/trento-project/"
  IMG_PREFIX_FOR_FORKS: "your-registry-username/"
  IMAGES_TO_PUSH: "trento-mcp-server"

jobs:
  # Set up environment variables and outputs for downstream jobs.
  setup:
    runs-on: ubuntu-latest
    outputs:
      # Output variables for use in other jobs.
      golang_version: ${{ steps.set-outputs.outputs.golang_version }}
      helm_version: ${{ steps.set-outputs.outputs.helm_version }}
      img_modifier: ${{ steps.set-outputs.outputs.img_modifier }}
      img_prefix: ${{ steps.set-outputs.outputs.img_prefix }}
      img_dev_tag: ${{ steps.set-outputs.outputs.img_dev_tag }}
      img_prod_tag: ${{ steps.set-outputs.outputs.img_prod_tag }}
      running_on_main: ${{ steps.set-outputs.outputs.running_on_main }}
      triggered_from_fork: ${{ steps.set-outputs.outputs.triggered_from_fork }}
      gh_username: ${{ steps.set-outputs.outputs.gh_username }}
    steps:
      # Checkout the repository.
      - uses: actions/checkout@v5
        name: Checkout
      # Show the GitHub event context for debugging.
      - name: Show GitHub event
        env:
          EVENT_CONTEXT: ${{ toJSON(github.event) }}
        run: echo $EVENT_CONTEXT | jq
      # Show the pull request context for debugging.
      - name: Show PR context
        env:
          PR_CONTEXT: ${{ toJSON(github.event.pull_request) }}
        run: echo $PR_CONTEXT | jq
      # Set output variables for downstream jobs.
      - name: Set outputs
        id: set-outputs
        env:
          PR_CONTEXT: ${{ toJSON(github.event.pull_request) }}
          PR_SOURCE_REPO_NAME: ${{ github.event.pull_request.head.repo.full_name }}
        run: |
          set -euo pipefail

          # Read versions from .tool-versions file (no fallbacks - must exist).
          GOLANG_VERSION=$(grep '^golang ' .tool-versions | cut -d' ' -f2)
          HELM_VERSION="v$(grep '^helm ' .tool-versions | cut -d' ' -f2)"

          if [[ "${GITHUB_REPOSITORY}" == "${TRENTO_REPO}" ]]; then
            echo "img_prefix=${IMG_PREFIX}" >> $GITHUB_OUTPUT
          else
            # When running in forks, push the images to a personal namespace if configured.
            echo "img_prefix=${IMG_PREFIX_FOR_FORKS}" >> $GITHUB_OUTPUT
          fi;

          # Check if the workflow is triggered due to a PR from an external fork.
          if [[ ("${PR_CONTEXT}" != "" && "${PR_CONTEXT}" != null) && "${PR_SOURCE_REPO_NAME}" != "${GITHUB_REPOSITORY}" ]]; then
            echo "triggered_from_fork=true" >> $GITHUB_OUTPUT
          else
            echo "triggered_from_fork=false" >> $GITHUB_OUTPUT
          fi

          if [[ ${GITHUB_REF_TYPE} == "tag" ]]; then
            echo "img_prod_tag=${GITHUB_REF_NAME}" >> $GITHUB_OUTPUT
            echo "version=${GITHUB_REF_NAME}" >> $GITHUB_OUTPUT
          else
            echo "img_prod_tag=latest" >> $GITHUB_OUTPUT
            echo "version=${GITHUB_SHA}" >> $GITHUB_OUTPUT
          fi;

          if [[ ${GITHUB_REF_NAME} == ${BRANCH_TRENTO_REPO} ]]; then
            echo "running_on_main=true" >> $GITHUB_OUTPUT
          else
            echo "running_on_main=false" >> $GITHUB_OUTPUT
          fi

          echo "golang_version=${GOLANG_VERSION}" >> $GITHUB_OUTPUT
          echo "helm_version=${HELM_VERSION}" >> $GITHUB_OUTPUT
          echo "img_modifier=${IMG_MODIFIER}" >> $GITHUB_OUTPUT
          echo "img_dev_tag=${IMG_DEV_TAG}" >> $GITHUB_OUTPUT
          # Set it directly in GitHub repository variables:.
          echo "gh_username=${{ vars.GH_USERNAME }}" >> $GITHUB_OUTPUT
      # Display the output variables for debugging.
      - name: Show outputs
        run: |
          set -euo pipefail
          echo "GOLANG_VERSION: ${{steps.set-outputs.outputs.golang_version}}"
          echo "HELM_VERSION: ${{steps.set-outputs.outputs.helm_version}}"
          echo "IMG_MODIFIER: ${{steps.set-outputs.outputs.img_modifier}}"
          echo "IMG_PREFIX: ${{steps.set-outputs.outputs.img_prefix}}"
          echo "IMG_DEV_TAG: ${{steps.set-outputs.outputs.img_dev_tag}}"
          echo "IMG_PROD_TAG: ${{steps.set-outputs.outputs.img_prod_tag}}"
          echo "RUNNING_ON_MAIN: ${{steps.set-outputs.outputs.running_on_main}}"
          echo "TRIGGERED_FROM_FORK: ${{steps.set-outputs.outputs.triggered_from_fork}}"
          echo "VERSION: ${{steps.set-outputs.outputs.version}}"
          echo "GH_USERNAME: ${{steps.set-outputs.outputs.gh_username}}"

  # Run all the linters.
  linters-run:
    if: inputs.run_linters
    needs:
      - setup
    uses: ./.github/workflows/linters.yaml
    secrets: inherit
    with:
      golang_version: ${{ needs.setup.outputs.golang_version }}

  # Check the result of all linters and fails if any linter failed.
  linters-result:
    if: inputs.run_linters && always()
    needs: linters-run
    runs-on: ubuntu-latest
    steps:
      # Fail the job if any linter did not succeed.
      - name: Check all linters result
        if: needs.linters-run.result != 'success'
        run: exit 1

  # Check go unit tests.
  test-with-go:
    needs:
      - setup
    runs-on: ubuntu-latest
    steps:
      # Checkout the repository.
      - uses: actions/checkout@v5
        name: Checkout
      # Read tool versions for environment setup.
      - uses: endorama/asdf-parse-tool-versions@v1
        name: Read .tool-versions
        id: tool-versions
      # Setup Go environment.
      - uses: actions/setup-go@v6
        with:
          go-version: ${{ needs.setup.outputs.golang_version }}
      # Cache Go modules for faster builds.
      - uses: actions/cache@v4
        name: Cache Go modules
        id: go-cache
        with:
          path: ~/go/pkg/mod
          key: go- ${{ needs.setup.outputs.golang_version }}-${{ hashFiles('**/go.sum') }}
      # Run Go unit tests.
      - name: Run go unit tests
        run: make test

  # Ensure the Helm chart is valid.
  test-chart-render:
    needs:
      - setup
    runs-on: ubuntu-latest
    steps:
      # Checkout the repository.
      - uses: actions/checkout@v5
        name: Checkout
      # Install Helm binary for chart validation.
      - name: Install Helm binary
        run: |
          set -euo pipefail
          HELM_VERSION="${{ needs.setup.outputs.helm_version }}"
          echo "Installing Helm ${HELM_VERSION}"
          pushd /tmp
          wget "https://get.helm.sh/helm-${HELM_VERSION}-linux-amd64.tar.gz"
          tar zxf "helm-$HELM_VERSION-linux-amd64.tar.gz"
          sudo mv linux-amd64/helm "/usr/local/bin/helm"
          popd
          echo "Done. Helm has been installed"
      # Run chart template test to ensure chart renders correctly.
      - name: Run chart template test
        run: |
          set -euo pipefail
          # Remove the kubeVersion field as it would fail otherwise as there isn't any k8s cluster.
          CHART_DIR=./helm/trento-mcp-server
          sed -i.bk -e "s/kubeVersion.*//g" "${CHART_DIR}/Chart.yaml"
          helm dep up "${CHART_DIR}"
          helm template "${CHART_DIR}" --debug

  # Build the container images.
  build-container-images:
    name: "Build ${{matrix.image}} image"
    needs:
      - setup
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        image:
          - trento-mcp-server
    steps:
      # Setup building process and output image name and file.
      - name: Setup building process
        id: setup
        run: |
          set -euo pipefail
          echo "img_name=${{matrix.image}}" >> $GITHUB_OUTPUT
          echo "img_file=/tmp/${{matrix.image}}-image.tar" >> $GITHUB_OUTPUT
      # Set container image metadata for tagging.
      - uses: docker/metadata-action@v5
        name: Set container image metadata
        id: meta
        with:
          images: ${{needs.setup.outputs.img_prefix}}${{steps.setup.outputs.img_name}}${{needs.setup.outputs.img_modifier}}
          flavor: latest=true
          tags: ${{needs.setup.outputs.img_dev_tag}}
      # Setup QEMU for multi-architecture builds.
      - uses: docker/setup-qemu-action@v3
        name: Setup QEMU
      # Setup Docker buildx for builds.
      - uses: docker/setup-buildx-action@v3
        name: Setup buildx
      # Build the container image using Docker.
      - uses: docker/build-push-action@v6
        name: Build container image
        env:
          DOCKER_BUILD_SUMMARY: false
          DOCKER_BUILD_RECORD_UPLOAD: false
        with:
          file: Dockerfile
          platforms: ${{ env.IMG_PLATFORMS }}
          tags: ${{ steps.meta.outputs.tags }}
          build-args: |
            VERSION=${{ needs.setup.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=${{ steps.setup.outputs.img_file }}
      # Upload the built image as an artifact.
      - uses: actions/upload-artifact@v4
        name: Upload artifacts
        with:
          name: ${{matrix.image}}-image
          path: ${{ steps.setup.outputs.img_file }}

  # Update sum.golang.org and pkg.go.dev.
  generate-docs:
    # This job triggers documentation update in Go module registries.
    if: needs.setup.outputs.running_on_main == 'true' || inputs.trigger_release
    runs-on: ubuntu-latest
    needs:
      - setup
      - build-container-images
      - test-chart-render
      - test-with-go
      - test-chart-render
      - linters-result
    steps:
      # Trigger docs update in Go registries.
      - uses: essentialkaos/godoc-action@v1
        name: Trigger docs update in sum.golang.org and pkg.go.dev

  # Push the container images to the registry.
  push_images:
    # This job pushes built container images to the registry.
    if: needs.setup.outputs.running_on_main == 'true' || inputs.trigger_release
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write # required for creating ghcr.io packages.
    needs:
      - setup
      - build-container-images
      - test-chart-render
      - test-with-go
      - test-chart-render
      - linters-result
    env:
      IMG_PROD_TAG: ${{ needs.setup.outputs.img_prod_tag }}
      IMG_PREFIX: ${{ needs.setup.outputs.img_prefix }}
    steps:
      # Log into the container image registry.
      - uses: docker/login-action@v3
        name: Log into the container image registry
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      # Download built image artifacts.
      - uses: actions/download-artifact@v5
        name: Download artifacts
      # Push container images to the registry.
      - name: Push container images to the registry
        run: |
          set -euo pipefail
          echo "IMAGES_TO_PUSH=\"${IMAGES_TO_PUSH}\"" >> $GITHUB_ENV
          for artifact in *; do
            echo "::debug::Processing artifact '${artifact}'"

            if [[ "${artifact}" != *"-image" ]]; then
              echo "::notice ::Skipping artifact ${artifact}, it's not a container image"
              continue
            fi

            image=${artifact/-image/}
            if [[ "${IMAGES_TO_PUSH}" != *"${image}"* ]]; then
              echo "::notice ::Skipping image ${image}, it's not an image to push"
              continue
            fi

            echo "::notice ::Loading image ${image}"
            docker load --input "${artifact}/${artifact}.tar"

            dev_image=${IMG_PREFIX}${image}${IMG_MODIFIER}:${IMG_DEV_TAG}
            prod_image=${IMG_PREFIX}${image}:${IMG_PROD_TAG}
            docker tag ${dev_image} ${prod_image}

            echo "::notice ::Pushing image ${prod_image}"
            docker push $prod_image
          done

  # Delete image artifacts, as they are not needed anymore
  # Delete image artifacts, as they are not needed anymore.
  cleanup:
    needs:
      - push_images
    runs-on: ubuntu-latest
    steps:
      # Delete image artifacts after pushing to the registry.
      - uses: geekyeggo/delete-artifact@v5
        name: Delete artifacts
        with:
          name: |
            *-image
