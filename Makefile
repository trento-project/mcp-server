# Copyright 2025 SUSE LLC
# SPDX-License-Identifier: Apache-2.0

# Makefile variables

# Directory to save the binaries to
BIN ?= ${CURDIR}/bin

# mcp-server-trento binary name
BIN_NAME = mcp-server-trento

IMAGE_REGISTRY ?= ghcr.io/trento-project
IMAGE_NAME ?= mcp-server
IMAGE_TAG ?= latest
IMAGE ?= $(IMAGE_REGISTRY)/$(IMAGE_NAME):$(IMAGE_TAG)

PORT ?= 5000

GO := "$(shell which go)"
DOCKER := "$(shell which docker)"


##@ General

help: ## Display this help.
	@awk 'BEGIN {FS = ":.*##"; printf "\nUsage:\n make \033[36m<target>\033[0m\n"} /^[a-zA-Z_0-9-]+:.*?##/ { printf " \033[36m%-15s\033[0m %s\n", $$1, $$2 } /^##@/ { printf "\n\033[1m%s\033[0m\n", substr($$0, 5) } ' $(MAKEFILE_LIST)

##@ Development

build: mcp-server-trento ## Build the entire project.

mcp-server-trento: ## Build the main project.
	$(GO) build -o "${BIN}/${BIN_NAME}" main.go

.PHONY: clean ## Delete the files generated by make build.
clean:
	$(GO) clean
	rm -f "${BIN}/${BIN_NAME}" || true

.PHONY: run
run: build ## Compile and run the project.
	$(GO) run main.go --port ${PORT} --oasPath ./api/openapi.json --transport streamable --oauth-enabled=false

##@ Test

.PHONY: test
test: ## Test the project.
	$(GO) test ./... -cover

##@ Code generation

.PHONY: generate
generate: install-tools ## Run code autogeneration from protobuf.
	$(MCPGEN) --doc=tools.md api/openapi.json

##@ Container

.PHONY: build-container
build-container: ## Build container image (eg. IMAGE=ghcr.io/trento-project/mcp-server:dev make build-container).
	$(DOCKER) build -t ${IMAGE} -f Dockerfile .

.PHONY: push-container
push-container: ## Push container image (eg. IMAGE=ghcr.io/trento-project/mcp-server make push-container).
	$(DOCKER) push ${IMAGE}

.PHONY: run-container
run-container: ## Push container image (eg. IMAGE=ghcr.io/trento-project/mcp-server make push-container).
	$(DOCKER) run -p ${PORT}:${PORT} ${IMAGE}

##@ Linters

.PHONY: fmt
fmt: ## Format source code.
	$(GO) fmt ./...

.PHONY: vet
vet: ## Run go vet against code.
	$(GO) vet ./...

.PHONY: vendor
vendor: ## Run go mod vendor.
	$(GO) mod vendor

.PHONY: tidy
tidy: ## Run go mod tidy.
	$(GO) mod tidy

.PHONY: fix-ending
fix-ending: ## Fix the line endings, converting them back to unix.
	find . -path "./.git" -prune -o -type f -exec dos2unix {} \+;

.PHONY: lint
lint: linter-license linter-shellcheck linter-yamllint linter-manifests ## Run all the linters.

.PHONY: linter-license
linter-license: ## Run license script.
	./hack/linters/license-linter.sh

.PHONY: linter-shellcheck
linter-shellcheck: ## Run shellcheck script.
	./hack/linters/shellcheck.sh

.PHONY: linter-yamllint
linter-yamllint: ## Run yamllint script.
	./hack/linters/yamllint.sh

.PHONY: linter-manifests
linter-manifests: helm kube-score ## Analyze the manifests with kube-score.
	$(HELM) template ./helm/trento-ai-companion | $(KUBE_SCORE) score -

##@ Dependencies

# Location to install dependencies to
LOCALBIN ?= "$(shell pwd)/bin"
$(LOCALBIN):
	mkdir -p $(LOCALBIN)

## Tool Binaries
KUBE_SCORE ?= $(LOCALBIN)/kube-score-$(KUBE_SCORE_VERSION)
HELM ?= $(LOCALBIN)/helm-$(HELM_VERSION)

## Tool Versions
KUBE_SCORE_VERSION ?= v1.20.0 # See https://github.com/zegl/kube-score/releases
HELM_VERSION ?= v3.18.4 # See https://github.com/helm/helm/releases

.PHONY: install-tools
install-tools: helm kube-score ## Download all the required tools.

.PHONY: helm
helm: $(HELM) ## Download helm locally if necessary.
$(HELM): $(LOCALBIN)
	$(call go-install-tool,$(HELM),helm.sh/helm/v3/cmd/helm,${HELM_VERSION})
	$(call check-gh-version,helm/helm,${HELM_VERSION})

.PHONY: kube-score
kube-score: $(KUBE_SCORE) ## Download the tool locally if necessary.
$(KUBE_SCORE): $(LOCALBIN)
	$(call go-install-tool,$(KUBE_SCORE),github.com/zegl/kube-score/cmd/kube-score,${KUBE_SCORE_VERSION})
	$(call check-gh-version,zegl/kube-score,${KUBE_SCORE_VERSION})

# go-install-tool will 'go install' any package with custom target and name of binary, if it doesn't exist
# $1 - target path with name of binary (ideally with version)
# $2 - package url which can be installed
# $3 - specific version of package
define go-install-tool
@[ -f $(1) ] || { \
set -e; \
package=$(2)@$(3) ;\
echo "Downloading $${package}" ;\
GOBIN=$(LOCALBIN) $(GO) install $${package} ;\
mv "$$(echo "$(1)" | sed "s/-$(3)$$//")" $(1) ;\
}
endef

# check-gh-version will 'go install' any package with custom target and name of binary, if it doesn't exist
# $1 - github "username/repository" pair
# $2 - version to check
define check-gh-version
@[ -f $(1) ] || { \
set -e; \
LATEST_VERSION=$$(curl --silent "https://api.github.com/repos/$(1)/releases/latest" | jq -r .tag_name) ;\
if [ $${LATEST_VERSION} != $(2) ]; then \
echo "[OUTDATED] Latest '$(1)' version is '$${LATEST_VERSION}', but using '$(2)'" ;\
fi ;\
}
endef
